■ CSS를 사용하는 이유
	(1) 표현할 수 있는 스타일이 다양하고, 세분화 되어있다.
		(CSS3) 동적인 요소의 표현까지 가능해짐
	(2) 구조와 스타일을 분리하여 작성할 수 있다.
	
■ CSS의 다양한 정의 방법(p.161 ~ p165) -> 어디에다 작성하는가
	(1) CSS파일 : 연결하는 모든 웹페이지가 스타일을 공유
			-html문서 안에서는 <link>태그를 사용하여 연결
			-CSS안에서는 @import url("주소");을 사용하여 연결
	(2) <style>태그 : 해당 문서안에서 여러 요소가 스타일을 공유
	(3) style속성(인라인style) : 해당 요소에만 스타일을 적용함
	
■ 셀렉터(=선택자)의 기본유형(p169~171)
	셀렉터 : CSS에서 대상을 구성하는 요소
	(1)태그셀렉터 : 해당 태그를 대상으로 스타일을 부여
	(2)ID셀렉터(#id) : 아이디를 대상으로 스타일을 부여
		- id속성은 중복 불가이다. 문서안에서 동일한 id값을 가지는 요소가 있으면 안된다.
	(3)class셀렉터(.class) : 클래스를 대상으로 스타일을 부여
		- class속성은 id속성과 다르게, 중복부여 가능하고 여러 값을 가지는 다중 부여도 가능
		
	※아이디명, 클래스명 부여시 주의사항
	  1. 숫자르 시작하면 안되고, 숫자로만 되어 있어도 안된다.
	  2. 클래스의 다중부여 경우를 제외하고, 띄어쓰면 안된다.

■ 가상클래스(:) - p173
  : 특정한 행위나 상태에 따라 스타일을 부여할 수 있게 함.(=유사클래스)
    □ 자식요소 가상 클래스
		- :first-child {첫번째 자식요소에게 스타일을 부여}
		- :last-child {마지막 자식요소에게 스타일을 부여}
		- :nth-child(m) {m번째 자식요소에게 스타일을 부여} 
	    	# m 은 양의 정수만 입력
		- :nth-chilld(m n) {m의 n배수번째 자식요소에게 스타일 부여}
			ex) li:nth-child(3n){3,6,9,12... 번째 자식인 li에게 스타일 부여}
			# n은 0부터 시작한 자연수가 대입
		-  :nth-child(m n+L) {L번쨰 부터 m의 배수로 증가하는 자식요소에게 스타일 부여}
			ex) p:nth-child(4n+3) {3,7,11,15,19... 번째 자식에게 스타일 부여}
		- :nth-child(odd) {홀수번째 자식요소에게 스타일 부여}
		- :nth-child(even) {짝수번째 자식요소에게 스타일 부여}
	□ 링크와 마우스 동적에 의한 가상클래스
		- a:link {링크가 설정된 경우, 스타일을 부여}
		- a:visited{방문한 링크인 경우, 스타일을 부여} 
		- a:focus{탭에 의해 선택된 경우, 스타일을 부여}
		- a:hover{마우스를 올렸을 때, 스타일을 부여}
		- a:active{클릭하는 순간, 스타일을 부여}
		# [link],[visited]는 링크가 설정된 a 태그에만 적용
		# [focus]는 링크가 설정된 a태그와 폼요소에 적용
		# [hover],[active]는 다른 태그에서도 적용 가능

		input:checked{체크박스나 라디오버튼에 체크된 상태인 경우 스타일 적용}

■ 가상요소(::) = 유사요소
	: 태그로 존재하지 않는 형태나 대상에 스타일을 부여함
	대상::before{} : 대상의 첫번째 자식보다 앞에 영역을 생성
	대상::after{} : 대상의 마지막 자식보다 뒤에 영역을 생성
	# ::before, ::after는 반드시 content 속성이 있어야함
	# ::before, ::after는 inline 형태를 가능해짐
	
	::placeholder{} : 입력폼에 나타나는 placeholder값을 스타일링함

■ 속성셀렉터 - p173
	[속성] { 해당 속성을 지닌 요소들이 스타일 대상이 됨 }
	(ex)
		<??? type="????"> </???>
		[type]{ "type" 속성을 가진 요소가 스타일을 적용받음}
	
	[속성="값"] { 해당 속성의 속성값을 지닌 요소가 스타일을 대상이 됨 }
	(ex)
		<??? name="no"> </???>
		[name="no"] { name속성의 속성값이 "no"인 경우, 스타일 적용 }
	
	[속성^="값"] { 해당 속성의 속성값이 "값"으로 시작하는 요소가 스타일 대상이 됨 }
	(ex)
		<<??? href="img/커피.html"> </???>
		<??? href="imgbox.css"> </???>
		[href^="img"] { href속성의 속성값이 "img"로 시작하는 요소가 스타일 대상이 됨 }
	
	[속성$="값"] { 해당 속성의 속성값이 "값"으로 끝나는 요소가 스타일 대상이 됨 }
	[속성*="값"] { 해당 속성의 속성값이 "값"을 포함하는 요소가 스타일 대상이 됨 }
	  	

■ 박스모델(p184)
	html태그는 네모난 사각형 박스로 다루어진다.
	[박스의 구성]
	(1)content영역 : 태그안, 내용을 작성하는 곳(텍스트나 또다른 태그)
		- width속성과 height속성에 의해 크기조절이 가능
	(2)padding영역 : 내부 여백(or 영역의 확장)
		- background만 표현됨
	(3)border영역 : 테두리
		
	(4)margin영역 : 외부 여백(or 상대적 위치)
		- 상대적 위치로 해석이 가능한 이유 : 마이너스 값이 사용 가능
		- content, padding, border은 마이너스 값 사용 불가
		
■ CSS우선순위 : 스타일의 적용순서
	- 우선순위가 높다 = 최종적으로 적용되는 스타일을 나타냄
	(1) 작성방식 상관없이, 작성순서가 나중에 작성된 스타일이 우선순위가 높다.
	(2) 1번보다, 대상을 구성하는 셀렉터의 수가 더 많은 쪽이 우선순위가 높다.	
	(3) tag셀렉터보다 class셀렉터가, class셀렉터보다 id셀렉터가 우선순위가 더 높다.
	(4) 인라인스타일이 우선순위가 가장 높다.
	#[!important]속성값 : 해당 속성값이 속성에 추가되면, 우선순위를 무시하고, 해당 스타일을 강제할 수 있다.
	
■ 기본 배치방식(진열방식) - p213    /*중요*/
	1. block 태그
		- div, h1~h6, p, ul, ol, dl, dt, dd, hr,
		  header, main, footer, nav, aside, section, article, address, form
		(1) 수직정렬
		(2) width 속성과 height속성을 사용하여 크기조절이 가능
		(3) 기본크기 : 너비는 부모와 같고, 높이는 내용만큼 설정
		
		
	2. inline태그
		- span, a, strong, em, i, (b, small, del, ins, sup, sub, mark)-p72 , label
		(1) 수평정렬
		(2) width 속성과 height속성을 사용하여 크기조절이 불가능
		(3) 기본크기 : 너비는 내용만큼, 높이는 글자 크기(font-size)만큼 설정
		(4) 태그 안에서 줄바꿈도 가능하고, 공백(띄어쓰기)를 인식함 = 글자와 같은 취급
		(5) 블록요소를 감쌀 수 없음(=블럭요소의 부모(조상)요소가 될 수 없음)
		(6) margin-top과 margin-bottom은 적용되지 않음
		(7) padding-top과 padding-bottom은 영향을 미치는 범위가 추가되지만 구조에는 영향을 주지 않음
			(다른 태그들이 인식하지 않음)
		
	3. inline-block태그
		=img, iframe, video, audio,input, textarea, select, button
		(1) 수평정렬
		(2) width 속성과 height속성을 사용하여 크기조절이 가능
		(3) 기본크기 : 너비는 내용만큼, 높이는 내용만큼 or 최소 행높이(line-height)만큼은 설정
		(4) 공백(띄어쓰기)를 인식
		(5) 블록요소를 감쌀 수 있음
		(6) 글자를 기준으로 크기 변경(추가적으로 기준을 정하는 작업을 해야함)
		
■ 블록요소를 수평정렬하는 방법
	1. display:inline or inline-block
		[유의할 점]
		(1) 크기조절이 안됨 margin(top,bottom)과 padding(top,bottom)이 적용 불가(inline)
		(2) 공백(띄어쓰기) 인식
		(3) 추가적으로 수평정렬되는 수직위치를 조정해줄 필요가 있다.
	
	2. float:left(right)
		[유의사항과 특징]
		(1) 가운데 정렬 불가
		(2) block 요소가 float 적용된 요쇼들을 인식하지 못함- ★
	[float요소 인식시키는 방법]
		Case 1) float 요소 다음에 오는 block 요소 인 경우
			: clear 속성을 사용하여 float 효과를 지움(float 요소를 인식시킴)
		Case 2) float 요소를 감싸는 부모 block인 경우
			① 부모 요소에게 float를 설정하거나, display:inline-block 사용
			  (부모가 수평할 때만)
			② 강제적으로 필요한 만큼의 높이값을 부여함
			③ 추후..
			④ float를 인식하는 마지막자식요소(block)를 추가한다.
		#clear:both(or left, right) : 선행되는 float효과를 지운다.




참고 사이트
 (1) MDN : http://developer.mozilla.org/
 (2) w3schools : http://www.w3schools.com/

[추가 CSS 스타일]
■ box-sizing : 크기조절의 기준 변경
  content-box(기본값) : content영역의 크기 조절
  border-box : border 영역까지 크기 조절

■ white-space : 백색공간 처리 방식 지정
  # 백색공간(white-space) : 보이지 않는 문자열 - 공백문자, 개행문자, 탭문자..
    normal(기본값) : 
	 - 자동줄바꿈됨
	 - 개행문자, 공백문자, 탭문자 병합됨(하나의 공백이 됨)
	nowrap : 
	 - 자동줄바꿈이 되지 않음
	 - 나머지는 normal과 같음
	pre : 
	 - 자동줄바꿈이 되지 않음
	 - 개행문자, 공백문자, 탭문자 등이 유지됨(페이지에 표현이 됨
  # 그 외, pre-wrap, pre-line, break-spaces는 나중에 따로 살펴볼 것

■ overflow : 넘치는 영역 처리하기
	visible(기본값) : 넘치는 영역을 그대로 표현
	hidden : 넘치는 영역을 숨김
	scroll : 스크롤 막대 영역 오른쪽과 아래에 생성
	auto : 넘치는 경우에만 스크롤 생성
	 
■ text-overflow : overflow의 hidden에 의해서 텍스트가 숨겨진 경우 표시방법
	clip(기본값) : 텍스트가 영역만큼만 표현되고, 넘치는 부분은 잘려서 표현
	ellipsis : 숨겨진 텍스트가 있는 경우, 말줄임표(...)으로 표현

	[사이트레이아웃 구성순서] = 사이트의 영역(구조)를 만드는 순서
	<div> : 범용적으로 사용되는 영역태그
=============================================================================================================	
■ 사이트레이아웃 구성순서
1. 사이트는 상단, 중앙, 하단으로 나눈다.
	<header> : 상단영역 - 사이트의 제목(로고)와 인터페이스 요소(네비게이션=메뉴)로 구성되는 영역
	<main> : 중단영역 - 페이지별로 컨텐츠(내용)가 구성되는 영역
				- 페이지당 하나만 사용되어야 함.
				- <div>를 제외한 다른 태그가 감쌀 수 없다.
	<footer> : 하단영역 - 회사 정보와 필수 표기사항, 사이트 관련 메뉴 등으로 구성되는 영역
	<aside> : 왼쪽/오른쪽 메뉴영역이나, 화면의 가장자리에 붙어있는 영역
	
2. 컨텐츠별로 영역을 생성해야 함
	(1) 작성순서는 위에서부터 아래로
	(2) 수평정렬인 경우는 왼쪽에서부터 오른쪽순으로 정렬
	<section> : 본문에서 컨텐츠별로 영역생성
	<article> : 독립된 컨텐츠 영역 생성, section의 하위 영역으로 만드는 경우 있음
	<nav> : 네비게이션(메뉴) 영역
	<address> : 주소, 회사정보, 연락정보 등을 표기하는 영역
		
3. 배경의 형태나, 공통된 스타일을 적용하기 위해, 추가적으로 영역을 생성한다.
	
4. 필요에 따라 만든다.
	
■ 박스(요소)의 배치 기준 설정하기(p217)
position : 요소(=태그)의 위치를 지정하는 방식(기준)을 설정
	:static;(기본값) : block 요소는 수직정렬, inline 요소들은 수평정렬 (normal flow)
	:absolute;
	:relative;
	:fixed; : 화면을 기준으로 위치가 지정

■ static을 제외한 다른 설정인 경우, 위치를 지정하는 속성 필요
	- 위치를 지정하는 속성 : [top], [left], [right], [bottom]

■ 각도의 단위
	(1) deg : 육십분법(360deg = 1회전)
	(2) grad : 그레이드법(400grad = 1회전)
	(3) rad : 호도법(2π rad = 1회전)
	(4) turn : 회전(1turn = 1회전)
